var documenterSearchIndex = {"docs":
[{"location":"#JuliennedArrays.jl","page":"JuliennedArrays.jl","title":"JuliennedArrays.jl","text":"","category":"section"},{"location":"","page":"JuliennedArrays.jl","title":"JuliennedArrays.jl","text":"Modules = [JuliennedArrays]","category":"page"},{"location":"","page":"JuliennedArrays.jl","title":"JuliennedArrays.jl","text":"Modules = [JuliennedArrays]","category":"page"},{"location":"#JuliennedArrays.Align-Union{Tuple{OuterDimensions}, Tuple{InnerDimensions}, Tuple{Item}, Tuple{AbstractArray{<:AbstractArray{Item, InnerDimensions}, OuterDimensions}, Vararg{Int64}}} where {Item, InnerDimensions, OuterDimensions}","page":"JuliennedArrays.jl","title":"JuliennedArrays.Align","text":"Align(slices, alongs::Int...)\n\nAlternative syntax: alongs is which dimensions will be taken up by the inner arrays.\n\njulia> using JuliennedArrays\n\njulia> input = reshape(1:8, 2, 2, 2)\n2×2×2 reshape(::UnitRange{Int64}, 2, 2, 2) with eltype Int64:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> slices = Slices(input, 1, 3)\n2-element Slices{SubArray{Int64, 2}, 1}:\n [1 5; 2 6]\n [3 7; 4 8]\n\njulia> Align(slices, 1, 3)\n2×2×2 Align{Int64, 3} with eltype Int64:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\nYou must include one along for each inner dimension. alongs should also be strictly increasing.\n\njulia> Align(slices, 1)\nERROR: ArgumentError: (1,) is not of length inner dimensions (2).\n[...]\n\nJulia can infer the result if alongs is constant.\n\njulia> using Test: @inferred\n\njulia> align_1_3(x) = Align(x, 1, 3);\n\njulia> @inferred align_1_3(slices)\n2×2×2 Align{Int64, 3} with eltype Int64:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8 \n\nslice_axes is the axes of one slice. If slices is empty, you can specify slice_axes manually.\n\njulia> Align([rand(3) for _ in 1:0], 1)\nERROR: BoundsError: attempt to access 0-element Vector{Vector{Float64}} at index [1]\n[...]\n\njulia> Align([rand(3) for _ in 1:0], 1; slice_axes = axes(rand(3)))\n3×0 Align{Float64, 2} with eltype Float64\n\n\n\n\n\n","category":"method"},{"location":"#JuliennedArrays.Align-Union{Tuple{OuterDimensions}, Tuple{InnerDimensions}, Tuple{Item}, Tuple{AbstractArray{<:AbstractArray{Item, InnerDimensions}, OuterDimensions}, Vararg{JuliennedArrays.TypedBool}}} where {Item, InnerDimensions, OuterDimensions}","page":"JuliennedArrays.jl","title":"JuliennedArrays.Align","text":"Align(slices, alongs::TypedBool...; slice_axes = axes(first(slices)))\n\nAlign an array of arrays, all with the same size.\n\nalongs, made of True and False objects, shows which dimensions will be taken up by the inner arrays. Inverse of Slices.\n\njulia> using JuliennedArrays\n\njulia> slices = [[1, 2], [3, 4]];\n\njulia> aligned = Align(slices, False(), True())\n2×2 Align{Int64, 2} with eltype Int64:\n 1  2\n 3  4\n\njulia> aligned[1, :] == slices[1]\ntrue\n\njulia> aligned[1, 1] = 0;\n\njulia> slices\n2-element Vector{Vector{Int64}}:\n [0, 2]\n [3, 4]\n\nWill throw an error if you try to align slices with different axes. Use @inbounds to skip this check.\n\njulia> unequal = [[1], [1, 2]];\n\njulia> Align(unequal, False(), True())\nERROR: ArgumentError: Slice [1, 2] does not have slice_axes (Base.OneTo(1),)\n[...]\n\nslice_axes is the axes of one slice. If slices is empty, you can specify slice_axes manually.\n\njulia> Align([rand(3) for _ in 1:0], True(), False())\nERROR: BoundsError: attempt to access 0-element Vector{Vector{Float64}} at index [1]\n[...]\n\njulia> Align([rand(3) for _ in 1:0], True(), False(); slice_axes = axes(rand(3)))\n3×0 Align{Float64, 2} with eltype Float64\n\n\n\n\n\n","category":"method"},{"location":"#JuliennedArrays.False","page":"JuliennedArrays.jl","title":"JuliennedArrays.False","text":"struct False\n\nTyped false\n\n\n\n\n\n","category":"type"},{"location":"#JuliennedArrays.Slices-Union{Tuple{Dimensions}, Tuple{AbstractArray{<:Any, Dimensions}, Vararg{JuliennedArrays.TypedBool, Dimensions}}} where Dimensions","page":"JuliennedArrays.jl","title":"JuliennedArrays.Slices","text":"Slices(whole, alongs::TypedBool...)\n\nSlice whole into views.\n\nalongs, made of True and False objects, shows which dimensions will be replaced with : when slicing.\n\njulia> using JuliennedArrays\n\njulia> whole = [1 2; 3 4];\n\njulia> slices = Slices(whole, False(), True())\n2-element Slices{SubArray{Int64, 1}, 1}:\n [1, 2]\n [3, 4]\n\njulia> slices[1] == whole[1, :]\ntrue\n\njulia> slices[1] = [2, 1];\n\njulia> whole\n2×2 Matrix{Int64}:\n 2  1\n 3  4\n\njulia> larger = rand(5, 5, 5);\n\njulia> larger_slices = Slices(larger, True(), False(), False());\n\njulia> size(first(larger_slices))\n(5,)\n\nYou must include one along for each dimension of whole.\n\njulia> using Test: @test_throws\n\njulia> @test_throws MethodError Slices(whole, True());\n\n\n\n\n\n","category":"method"},{"location":"#JuliennedArrays.Slices-Union{Tuple{Dimensions}, Tuple{Item}, Tuple{AbstractArray{Item, Dimensions}, Vararg{Int64}}} where {Item, Dimensions}","page":"JuliennedArrays.jl","title":"JuliennedArrays.Slices","text":"Slices(whole, alongs::Int...)\n\nAlternative syntax: alongs is which dimensions will be replaced with : when slicing.\n\njulia> using JuliennedArrays\n\njulia> input = reshape(1:8, 2, 2, 2)\n2×2×2 reshape(::UnitRange{Int64}, 2, 2, 2) with eltype Int64:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> s = Slices(input, 1, 3)\n2-element Slices{SubArray{Int64, 2}, 1}:\n [1 5; 2 6]\n [3 7; 4 8]\n\njulia> map(sum, s)\n2-element Vector{Int64}:\n 14\n 22\n\nNo along should be greater than the number of dimensions of whole. alongs should also be strictly increasing.\n\njulia> Slices(input, 4)\nERROR: ArgumentError: 4, a dimension number, is out of bounds or out of order.\n[...]\n\nYou can infer the result if the dimensions are constant.\n\njulia> using Test: @inferred\n\njulia> slices_1_3(x) = Slices(x, 1, 3);\n\njulia> @inferred slices_1_3(input)\n2-element Slices{SubArray{Int64, 2}, 1}:\n [1 5; 2 6]\n [3 7; 4 8]\n\n\n\n\n\n","category":"method"},{"location":"#JuliennedArrays.True","page":"JuliennedArrays.jl","title":"JuliennedArrays.True","text":"struct True\n\nTyped true\n\n\n\n\n\n","category":"type"}]
}
